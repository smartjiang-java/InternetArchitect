# 01:计算机组成原理,操作系统

## 计算机
```
用电来替代数字0和1
电子管----------(遇到半导体,PN结,从而形成二极管)--------场效应晶体管-----------逻辑开关      
计算机通电--->cpu读取内存中程序(电信号输入)--->时钟发生器不断振荡通断电,给cpu的针脚通电传递0和1
 --->推动cpu内部一步一步执行(执行多少次取决于指令需要的时钟周期)---->计算完成--->写回(电信号)内存
 ---->写给显卡输出(sout,或者图形)

如何让计算机计算?
手工输入:纸带计算器,打点为1,不打为0
汇编语言:把一串0101..标识成助记符(mov ,add等),所以说汇编语言就是机器语言

量子计算机
量子比特:qb,那一位同时是1和0

```

## java相关硬件知识
```
cpu,内存   一般都是插到主板上
总线:系统总线,IO总线,内存总线

内存是cpu的仓库,只要一断电,内存就会恢复成初始状态   jvm将java编译后后的bytecode解释成机器码,给内存执行  

32位:
64位: cpu一次能都读多少位0和1,即低电平和高电平

cpu的基本组成: 
   PC->指令寄存器,程序计数器,记录当前指令地址
   Registers->寄存器,暂时存储cpu计算机需要用到的数据
   Alu->逻辑运算单元,做运算用的
   CU->控制单元
   MMU-<Memory Management Unit 内存管理单元\
   catch->

超线程:一个ALu对应多个PC| Registers   所谓的四核八线程
线程切换的时候,会把上一个未执行完的的线程数据存放到缓存

读取数据的时候是按块读取,程序的局部性原理,可以提高效率,充分发挥总线cpu针脚等一次性读取更多数据的能力
缓存一致性协议  inter的叫MESI Cache  cpu的每个cache line标记四种状态(额外两位)
锁总线 比一致性协议效率低,如果缓存行装不下
缓存行一般是64字节,缓冲行越大,局部性空间效率越高,读取时间越慢
--->对于有些特别敏感的数字,会存在线程高竞争的访问,为了保证不发生伪共享,
---->诞生了一种编程模式,叫做缓存行对齐,关键数据的前面有七个lang,后面有七个lang ,类似disuptor
---->在jdk8里面,可以使用@Contended,需要加上:JVM-XX:-RestrictContended 保证此数据不与其他数据在一个缓存行

```

## cpu的乱序执行,目的是为了提高效率,同时执行
```
概念:不需要等待上一条指令执行完成后才去执行第二条指令,如果两条执行没有依赖关系,两条指令会同时执行,第二条指令可能比第一条还要先完成
cpu层面如何禁止重排序?
--->内存屏障,对某部分内存做操作时前后添加的屏障,屏障前后的操作不可以乱序执行
cpu层面:Intel的cpu -> 原语(mfence读写屏障 lfence读屏障, sfence写屏障) 或者锁总线,volatile使用的是lock汇编指令,锁住一条内存总线
        使用原语肯定是比lock指令效率高,但是上面的原语只有inter有,其他cpu不一定有,但是lock指定很多cpu都有
JVm层面:8个hanppens-before原则 4个内存屏障 （LL LS SL SS）
注意:不管如何重排序,单线程执行结果不会改变,尽管可能会重排序, as if serial


### 合并写（不重要）
wc-Write Combining 合并写技术
由于ALU速度太快，所以在写入L1的同时，写入一个WC Buffer，满了之后(一般是4字节),再直接更新到L2

### NUMA
UMA：多个Cpu通过一条总线访问内存,不易扩展,cpu数量增多后引起内存访问冲突,4颗比较合适
NUMA:Non Uniform Memory Access 每个cpu优先访问自己插槽上的内存
ZGC - NUMA aware 

```

## os操作系统
```







```
